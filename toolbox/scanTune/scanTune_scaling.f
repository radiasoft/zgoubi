C      subroutine srchCO(nCO,xK,xiDeg)
C Starting from initial coordinates near closed orbits, as read from input file 
C zgoubi.dat (possibly generated by geneMap), look for precise co's
C works like scanTune, yet does vertical co search in addition (flag kaseV=2) 
C (note : this is in case v_co not zero due for instance to some V kicker, or defects...)
      implicit double precision (a-h,o-z)

      parameter (lunR=11,lunW=12)
      character txt132*132, let*1, txt132c*132, cmnd*132
      parameter (nCOmx=10001, maxIter=20)
      dimension x(nCOmx),xp(nCOmx),z(nCOmx),
     >                   zp(nCOmx),s(nCOmx),d(nCOmx),let(nCOmx)
      dimension clorb(7,nCOmx)
      character cmmnd*110

      logical ok, strcon, first, idluni

      integer debstr, finstr

      logical reb, empty

      character txtStep*40, txtSample*40       
      
C mxbr=10 is the max number of timings that scaling with option 1.11 will accept
      parameter (mxbr=100)
      dimension brolst(mxbr), Qxlst(mxbr), Qylst(mxbr)
     >    , vxlst(mxbr), vylst(mxbr)

      data vxlst, vylst / mxbr*1.d0,  mxbr*1.d0  /
      data ok, first / .false., .true. /
      data txtStep, txtSample / ' 0.02  stepSize',    
     > '.001 .001 .001 .001 0. .001         ' /
c      data brolst /  7205.1777, 7255., 7380., 7392., 7429., 7653., 7877.
c     >, 8325., 8773., 9221. /

C Requested precision on co (cm, mrad)
C Careful here :  PREC MUST BE COMPATIBLE with precision on x and xp as read in zgoubi.res
      data precX, precXp / .01d0, .01d0 /     ! zgoubi units cm, mrad
C      data precX, precXp / .0001d0, .001d0 /
      data  kaseV / 2 /
      data  dpp / 1.d-3 /

      cmnd = 'mv -f scanTune.Out scanTune.Out_old'
      write(*,*) '++++++ ',cmnd
      call system(cmnd)
      cmnd = 'mv -f scanTune.Out2 scanTune.Out2_old'
      write(*,*) '++++++ ',cmnd
      call system(cmnd)
      cmnd = 'rm -f fort.88 ; rm fort.89'
      write(*,*) '++++++ ',cmnd
      call system(cmnd)
      if (idluni(lunOut2)) 
     >   open(unit=lunOut2,file='scanTune.Out2')

      if (idluni(lunIn)) then
        open(unit=lunIn,file='scanTune.In',err=25)
C        read(lunIn,*,err=24,end=24) brhomi, brhoma, ndb  ! kG.cm
        read(lunIn,*,err=25,end=25) ndb
        read(lunIn,*,err=25,end=25) (brolst(i),i=1,ndb)  ! kG.cm
        read(lunIn,*,err=25,end=25) (Qxlst(i),i=1,ndb) 
        read(lunIn,*,err=25,end=25) (Qylst(i),i=1,ndb) 
        read(lunIn,*,err=25,end=25) (vxlst(i),i=1,ndb) 
        read(lunIn,*,err=25,end=25) (vylst(i),i=1,ndb) 
        goto 24
 25     continue
        rewind(lunIn)
C        write(lunIn,*) brhomi, brhoma, ndb,' brhomi, brhoma, # steps'
        brolst(1) = (brolst(1) *1.d6 + 1.d0) *1.d-6
        write(lunIn,*) ndb
        write(lunIn,fmt='(f14.6,49f12.4)') (brolst(i),i=1,ndb)
        write(lunIn,fmt='(50f12.4)') (Qxlst(i),i=1,ndb)
        write(lunIn,fmt='(50f12.4)') (Qylst(i),i=1,ndb)
        write(lunIn,fmt='(50f12.4)') (vxlst(i),i=1,ndb)
        write(lunIn,fmt='(50f12.4)') (vylst(i),i=1,ndb)
 24    continue
        close(lunIn)
      else
        stop 'Pgm scantune_scaling, stop upon open scanTune.In'
      endif

      write(*,*) 'ndb,(brolst(i),i=1,ndb) :',
     >      ndb,(brolst(i),i=1,ndb)

      if(ndb.gt.mxbr) then
        write(*,*)  'Pgm scanTune_scaling Too many data. Max a'
     >                 ,'llowed is .le.mxbr.'
        stop
      endif

      open(unit=lunR,file='zgoubi_scanTune-In.dat')

      cl9 = 2.99792458D8 / 1.d9

C      brho = brhomi
C      dBrho = (brhoma - brhomi)/dble(ndb)

      noc =1
 2    continue
        brho = brolst(noc) 
        write(*,*) ' noc, Brho : ',noc, Brho
        rewind(lunR)
        open(unit=lunW,file='zgoubi.dat')
        rewind(lunW)

        read(lunR,fmt='(a)') txt132
        write(lunW,fmt='(a)') 'Data generated by scanTune '
        read(lunR,fmt='(a)') txt132
        write(lunW,*) txt132(debstr(txt132):finstr(txt132))
        read(lunR,fmt='(a)') txt132
        read(txt132,*) BORO
        write(*,*) ' Reference rigidity BRho = ',Brho/1000.d0,' T.m' 
        write(lunW,*) Brho

 1      continue
          read(lunR,fmt='(a)',end=10,err=10) txt132
c          if(strcon(txt132,'./V_tune_I',10,
c     >                                     IS)) then
          if(txt132(debstr(txt132):finstr(txt132)) .eq. './V_tune_I') 
     >                                     then
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               

            read(lunR,fmt='(a)',end=10) txt132
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            read(lunR,fmt='(a)',end=10) txt132
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            read(lunR,fmt='(a)',end=10) txt132
            if(noc.eq.1) then
              write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            else
C              write(lunW,*) varV
C              write(lunW,*) ' 1. '
              write(lunW,*) vylst(noc)
            endif
            read(lunR,fmt='(a)',end=10) txt132
C            write(lunW,*) Brho
            write(lunW,*) ' 0.d0 '

          elseif(txt132(debstr(txt132):finstr(txt132)).eq. './H_tune_I') 
     >                                     then
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               

            read(lunR,fmt='(a)',end=10) txt132
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            read(lunR,fmt='(a)',end=10) txt132
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            read(lunR,fmt='(a)',end=10) txt132
            if(noc.eq.1) then
              write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            else
C              write(lunW,*) varH
C              write(lunW,*) ' 1. '
              write(lunW,*) vxlst(noc)
            endif
            read(lunR,fmt='(a)',end=10) txt132
C            write(lunW,*) Brho
            write(lunW,*) ' 0.d0 '

          elseif(strcon(txt132,'''FIT''',5,
     >                                     IS)
     >      .or. strcon(txt132,'''FIT2''',6,
     >                                      IS)) then
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               

            read(lunR,fmt='(a)',end=10) txt132
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            read(txt132,*) nvar
            do iv = 1, nvar
              read(lunR,fmt='(a)',end=10) txt132
              write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            enddo
            read(lunR,fmt='(a)',end=10) txt132
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               
            read(txt132,*) ncon
            do ic = 1, ncon
              read(lunR,*) typ, ii, jj, nl, val, we, np
              if(ic.eq.1) val = Qxlst(noc)
              if(ic.eq.2) val = Qylst(noc)
              write(lunW,fmt='(f3.1,2(1x,i1),1x,i4,2(1x,f6.4),1x,i2)')
     >                   typ, ii, jj, nl, val, we, np
            enddo

          else
            write(lunW,*) txt132(debstr(txt132):finstr(txt132))               

          endif

        goto 1

 10     continue

        close(lunW)
       
        cmnd = '~/zgoubi/source/zgoubi_intel'
        write(*,*) '++++++ ',cmnd
        call system(cmnd)

C Get fit value from zgoubi.res
        if (idluni(lunW3)) 
     >     open(unit=lunW3,file='zgoubi.res')

          open(unit=88,file='fort.88')

          read(lunW3,fmt='(a)',end=10,err=10) txt132
          read(lunW3,fmt='(a)',end=10,err=10) txt132
          read(lunW3,*) boro

 12       continue
          read(lunW3,fmt='(a)',end=11,err=11) txt132

          if(strcon(txt132,'STATUS OF VARIABLES',19,
     >                                     IS)) then

            read(lunW3,fmt='(a)',end=10) txt132
            read(lunW3,fmt='(a)',end=10) txt132
            read(txt132,*) idum,idum,idum,dum,dum,varH
            read(lunW3,fmt='(a)',end=10) txt132
            read(txt132,*) idum,idum,idum,dum,dum,varV

            read(lunW3,fmt='(a)',end=10) txt132

            read(lunW3,fmt='(a)',end=10) txt132
            read(lunW3,fmt='(a)',end=10) txt132
            read(txt132,*) idum,idum,idum,idum,dum,dum,QH
            read(lunW3,fmt='(a)',end=10) txt132
            read(txt132,*) idum,idum,idum,idum,dum,dum,QV

            write(88,fmt='(a,1p,e15.6)') ' ',varH
            write(88,fmt='(a,1p,e15.6)') ' ',boro
            write(88,fmt='(a,1p,e15.6)') ' ',varV
            write(88,fmt='(a,1p,e15.6)') ' ',boro
            write(88,fmt='(a,1p,e15.6)') ' ',QH
            write(88,fmt='(a,1p,e15.6)') ' ',QV
            write(88,fmt='(a,1p,i4)') ' ',noc

            write(lunOut2,fmt='(1p,5(1x,e15.6),1x,i4)') 
     >         varH,varV,boro,QH,QV,noc

          else
            goto 12

          endif

 11     continue

        close(lunW3)
        close(88)

        if(noc.eq.1) then
          cmnd = 'cp -f fort.88 scanTune.Out '
          write(*,*) '++++++ ',cmnd
          call system(cmnd)
        else
          cmnd = 'paste scanTune.Out fort.88 >> temp ; 
     >    mv temp scanTune.Out ; rm -f fort.88'
          write(*,*) '++++++ ',cmnd
          call system(cmnd)
        endif         
       
C        Brho = Brho + dBrho
        noc = noc+1

C        if(Brho.le.Brhoma) goto 2
        if(noc.le.ndb) goto 2

      close(lunOut2)

      write(*,*) ' '
      write(*,*) 'Job "scanTune" ended, hopefully well... '
      write(*,*) ' '
      stop
      end
      FUNCTION STRCON(STR,STRIN,NCHAR,
     >                                IS)
      implicit double precision (a-h,o-z)
      LOGICAL STRCON
      CHARACTER STR*(*), STRIN*(*)
C     ------------------------------------------------------------------------
C     .TRUE. if the string STR contains the string STRIN with NCHAR characters
C     at least once.
C     IS = position of first occurence of STRIN in STR
C     ------------------------------------------------------------------------

      INTEGER DEBSTR,FINSTR

      II = 0
      DO 1 I = DEBSTR(STR), FINSTR(STR)
        II = II+1
        IF( STR(I:I+NCHAR-1) .EQ. STRIN ) THEN
          IS = II
          STRCON = .TRUE.
          RETURN
        ENDIF
 1    CONTINUE
      STRCON = .FALSE.
      RETURN
      END
      FUNCTION DEBSTR(STR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DEBSTR
      CHARACTER * (*) STR
C     -----------------------------------
C     Renvoie dans DEBSTR le rang du
C     premier caractere non-blanc de STR.
C     -----------------------------------
      DEBSTR=0
      LENGTH=LEN(STR)+1
1     CONTINUE
         DEBSTR=DEBSTR+1
         IF(DEBSTR.GE. LENGTH) RETURN
         IF (STR(DEBSTR:DEBSTR).EQ. ' ') GOTO 1
      RETURN
      END
      FUNCTION FINSTR(STRING)
      implicit double precision (a-h,o-z)
      INTEGER FINSTR
      CHARACTER * (*) STRING
C     --------------------------------------
C     RENVOIE DANS FINSTR LE RANG DU
C     DERNIER CHARACTER NON BLANC DE STRING,
C     OU BIEN 0 SI STRING EST VIDE ou BLANC.
C     --------------------------------------

      FINSTR=LEN(STRING)+1
1     CONTINUE
        FINSTR=FINSTR-1
        IF(FINSTR .EQ. 0) RETURN
        IF (STRING(FINSTR:FINSTR) .EQ. ' ') GOTO 1

      RETURN
      END
      FUNCTION IDLUNI(LN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL IDLUNI

      LOGICAL OPN

      I = 20
 1    CONTINUE
        INQUIRE(UNIT=I,ERR=99,IOSTAT=IOS,OPENED=OPN)
        I = I+1
        IF(I .EQ. 100) GOTO 99
        IF(OPN) GOTO 1
        IF(IOS .GT. 0) GOTO 1
      
      LN = I-1
      IDLUNI = .TRUE.
      RETURN

 99   CONTINUE
      LN = 0
      IDLUNI = .FALSE.
      RETURN
      END

      FUNCTION EMPTY(STR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL EMPTY
      CHARACTER*(*) STR
C     -----------------------------------------------------
C     .TRUE. if STR is either empty or contains only blanks
C     -----------------------------------------------------

      INTEGER FINSTR
      EMPTY = FINSTR(STR) .EQ. 0
      RETURN
      END
