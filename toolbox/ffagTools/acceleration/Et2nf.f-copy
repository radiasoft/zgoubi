C Transform the  orbit duration vs Energy dependence,  as obtained from eg prior run of 
C geneMap, into freq as a function of turn number. 
C Input data are read in searchCO.out_COs ; Et2nf.In gives additional working 
C conditions data, output is printed Et2nf.out, for further read by the SCALING procedure 
C when running CAVITE for acceleration in zgoubi. 

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      parameter(nd=2000)
C tau is turn duration on closed orbit at energy E
      dimension turn(nd), freq(nd), Ekin(nd), tau(nd)

      character let*1
      integer*4 nbTrn
C-------------------------- 
C User's orking data  
      open(unit=7,file='Et2nf.In')  
      read(7,*) nCell, Vp, phsD, E1, E2
      close(7)

        ak = 4.415d0
      am = 938.27231e6
      kTrStp = 1
      kTrStp2 = 200
C--------------------------

      pi = 4.d0 * atan(1.d0)
      phs = phsD /180. * pi
      dE = Vp  * sin(phs)
      nbTrn = (E2-E1)/dE
C the prgrm works with MeV
      am = am * 1.d-6
      dE = dE * 1.d-6
      E1 = E1 * 1.d-6
      E2 = E2 * 1.d-6  * 1.2

      write(6,*) '  Vp, phsD, E1, E2, dE, #turns :', 
     >                        Vp, phsD, E1, E2, dE, nbTrn

      open(unit=7,file='Et2nf.In2')  
      open(unit=8,file='Et2nf.Out')  

          i = 1
          j = nd
 1    continue
C read closed orbit coordinates and duration (tau)
        read(7,*,err=598,end=599) x,xp,z,xp,s,d,tco,let,E
          if(j.eq.nd/2) stop '  Too many data'
          turn(j) = 1.d0+(E-E1)/dE
          tau(j) = tco * nCell 
          freq(j) = 1.d0/tau(j) 
          Ekin(j) = E 
c          write(88,fmt='(1p,3e14.6,2x,i6,a)') 
c     >      turn(j),freq(j),tau(j),j,'  turn#, freq.(MHz), tau(mu_s), j'
          j = nd-i
          i = i+1
        goto 1

      close(7)
      close(8)

c            write(88,*) '% -------------------- '

 598      write(*,*) '  read ended upon EOF, # data read is ',i-1
          goto 21
 599      write(*,*) '  read ended upon error, # data read is ',i-1
          goto 21
 21       continue

c            write(88,*) '% -------------------- '

            n = i-1
            write(*,*) ' # of data to be interpolated :  n= ',n
            if(n.eq.0) stop ' SBR CUBSPL, no data to be interpolated'

c        write(88,*) '% -------------------- '

C Reverses the array so to have turn increasing with increasing index
            if(turn(nd).gt.turn(nd-1)) then
              do 3 i = 1, n
                turn(i) = turn(nd-n+i)        
                freq(i) = freq(nd-n+i)        
                tau(i) = tau(nd-n+i)        
                Ekin(i) = Ekin(nd-n+i)        
                write(88,fmt='(1p,4e14.6,2x,i5,2X,a)') 
     >           turn(i), freq(i), tau(i), Ekin(i), i,
     >           'turn, freq, tau, Ekin, i   '
 3            continue
            else
              do 5 i = 1, n
                turn(n-i+1) = turn(nd-n+i)        
                freq(n-i+1) = freq(nd-n+i)        
                tau(n-i+1) = tau(nd-n+i)        
                Ekin(n-i+1) = Ekin(nd-n+i)        
                write(88,fmt='(1p,2e14.6,i5)') turn(i), freq(i), i                         
 5           continue
            endif

c        write(88,*) '% ---------------- ',nv,nint(turn(1)),int(turn(n))

C------ In order to compute "one" :
        xv = float(1)
        yv = CUBSPL(turn,freq,xv,nd,n)
        tt1 = CUBSPL(turn,tau,xv,nd,n)
        ek1 = CUBSPL(turn,Ekin,xv,nd,n)
        p1 = ((ek1+am)**2 - am*am)**(0.5d0)
C----------------------------------

      nv1 = nint(turn(1))
      nv2 = int(turn(n))
        write(*,*) '  nv1, nv2 : ', nv1, nv2 
c         pause
      sytdx = 0.d0      
      stt = 0.d0
      xv = 1.d0
      yv = CUBSPL(turn,freq,xv,nd,n)
      tt = CUBSPL(turn,tau,xv,nd,n)
      stt = tt
      phase = 2.d0 * pi * sytdx
      ek = CUBSPL(turn,Ekin,xv,nd,n)
      p = ((ek+am)**2 - am*am)**(0.5d0)
      one = tt1/tt * (p/p1)**(-ak/(ak+1.d0))  * (ek+am)/(ek1+am)
      write(8,fmt='(1p,6e16.8,2x,i7,5x,a)') xv,yv,phase,stt,ek,one, 
     >     nv/kTrStp,   'turn#, freq, phi, oclock, Ekin'
      do 6 nv = kTrStp+1, nv2, kTrStp
        xv = dble(nv)
        yv = CUBSPL(turn,freq,xv,nd,n)
        tt = CUBSPL(turn,tau,xv,nd,n)
        stt = stt + tt*kTrStp
c        sytdx = sytdx + yv * tt * kTrStp
c        phase = 2.d0 * pi * sytdx
        phase = 2.d0 * pi * (xv-1.d0)
        ek = CUBSPL(turn,Ekin,xv,nd,n)
        p = ((ek+am)**2 - am*am)**(0.5d0)
C           write(*,*) tt,tt1, p, p1, ek, am
C So to check scaling of time duration : 
        one = tt1/tt * (p/p1)**(-ak/(ak+1.d0))  * (ek+am)/(ek1+am)
C Print frequency law xv, yv :
C        if(mod(nv-kTrstp-1,kTrstp2) .eq. 0) 
        if(mod(nv-1,kTrstp2) .eq. 0) 
     >   write(8,fmt='(1p,6e16.8,2x,i7,5x,a)') xv,yv,phase,stt,ek,
     >            yv*tt*kTrStp - kTrStp,
     >     nv/kTrStp,   'turn#, freq, phi, oclock, Ekin'
 6    continue

      stop
      end

      FUNCTION CUBSPL(xm,ym,xv,nd,n)
C Fake
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      integer nd,n,i,m,j,k,count,sele
      doubleprecision 
     >XM(nd),YM(nd),LM(nd),UM(nd),DM(nd),CM(0:nd),EM(nd),
     >xv,fact,e,ff,g,h

      i = interv(xm,xv,nd)

      a = (xm(i+1) - xv) / (xm(i+1) - xm(i))
      b = 1.d0 - a

      cubspl = a * ym(i) + b * ym(i+1)

      return
      end
      FUNCTION interv(xm,xv,nd)
C Fake
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension XM(*)

      if(xv.le.xm(2)) interv = 1
      if(xv.ge.xm(nd-1)) interv = nd-1

      return
      end


***CUBIC SPLINE********************************************************
*                  INTERPOLATION USING CUBIC SPLINES                  *
***********************************************************************
*
      FUNCTION CUBSPL_I(xm,ym,xv,nd,n)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      integer nd,n,i,m,j,k,count,sele
      doubleprecision 
     >XM(nd),YM(nd),LM(nd),UM(nd),DM(nd),CM(0:nd),EM(nd),
     >xv,fact,e,ff,g,h
** 
**
      cubspl = 9999.d0

      m = n - 1
      j = m - 1
      k = j - 1
**
*  GENERATION OF TRIDIAGONAL SYSTEM FOR SECOND DERIVATIVE
**
      do 10 i = 1,j
         DM(i) = 2.* (XM(i+2) - XM(i))
         CM(i) = 6.* (YM(i+2) - YM(i+1)) / (XM(i+2) - XM(i+1)) + 6.* 
     $                         (YM(i) - YM(i+1)) / (XM(i+1) - XM(i))
10    continue
      do 20 i = 2,j
         LM(i) = XM(i+1) - XM(i)
20    continue
      do 30 i = 1,k
         UM(i) = XM(i+2) - XM(i+1)
30    continue 
**
*  SOLUTION OF TRIDIAGONAL SYSTEM
**
      CALL TRIDI(LM,DM,UM,CM,nd,j)
** 
**
*  EVALUATION AND PRINTING OF CUBIC SPLINES
**
      CM(0) = 0.
      CM(n) = 0.
c      write(6,*)'------------------------------------------------------'
c      sele = 1
c40    if (sele.eq.1) then
c         write(6,*) ' Enter the value where interpolation is required:'
c         read(*,*) xv
c         write(6,*) 'The equation for cubic splines are:'
         do 50 i = 1,m
            fact = XM(i+1) - XM(i)
            e = CM(i-1) / (6.*fact)
            ff = CM(i) / (6.*fact)
            g = (YM(i)/fact) - (CM(i-1)*fact/6.)
            h = (YM(i+1)/fact) - (CM(i)*fact/6.)
            EM(i) = e* (XM(i+1) - xv) **3 + ff* (xv - XM(i)) **3 + 
     $              g* (XM(i+1)- xv) + h* (xv - XM(i))
c            write(6,41) 'f',i,'x =',e,'(',XM(i+1),'-x)**3 +',ff,
c     $      '(x-',XM(i),')**3 +',g,'(',XM(i+1),'-x)+',h,'(x-',XM(i),')'
c41          format('0',a1,i1,a3,f7.3,a1,f7.3,a8,f7.3,a3,f7.3,a6,f7.3,a1,
c     $             f7.3,a4,f7.3,a3,f7.3,a1)
50       continue 
**
*  SELECTION OF APPROPRIATE SEGMENT (BASED ON THE VALUE) WHERE
*  INTERPOLATION REQUIRED
**
         count = 1
60       if (xv.lt.XM(count+1)) go to 70
         count = count + 1
         go to 60
70       continue 
** 
**
c         write(6,*)'--------------------------------------------------'
c         write(6,71) xv,EM(count)
c71       format('0',5x,'The interpolated value at',f6.2,' is:',f8.3)
c         write(6,*)'--------------------------------------------------'
c         write(6,*)' More Interpolation ?  < 0- for NO / 1- for YES >:'
c         read(*,*) sele
c         go to 40
        CUBSPL = EM(COUNT)
c      endif
      return
c      stop
      end
*
***TRIDIAGONAL MATRIX******************************************************
*                                                                         *
      subroutine TRIDI(L,D,U,COE,nd,n)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c      integer nd,n,m,i
      integer m,i
c      parameter(nd=40)
      doubleprecision L(nd),D(nd),U(nd),COE(nd)
**
      m = n - 1 
      do 10 i = 1,m
         L(i+1) = L(i+1) / D(i)
         D(i+1) = D(i+1) - L(i+1) *U(i)
         COE(i+1) = COE(i+1) - L(i+1) *COE(i)
10    continue
**
*  THE COEFFICIENT VECTOR WILL TRANSFORM TO SOLUTION VECTOR*
**
      COE(n) = COE(n)/D(n)
      do 20 i = m,1,-1
         COE(i) = (COE(i) - U(i) *COE(i+1)) / D(i)
20    continue
      return
      end


