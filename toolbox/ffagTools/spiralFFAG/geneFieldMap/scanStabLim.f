c read tunes from zpop as following from prior exec of zgoubi
      logical exs, strcon, result, existCO, first
      character txt132*132, txt10*10
      character rep*1
      
      data first / .true. /
      data lunIn, lunOut, lunData / 7, 8, 13 / 

      CHARACTER  HMS*8, DMY*9

      write(6,*) 
      write(6,*) '--------------------------------------------'
      write(6,*) ' scanStabLim procedure now launched...' 

C Tunes from multiturn
      kTunes = 1
C Tunes from MATIX
      kTunes = 2

      call system('cat scanKXi.out_COs >> scanKXi.out_COs_old ; 
     >      rm -f  scanKXi.out_COs ')
      call system('cat scanKXi.out_Qs >> scanKXi.out_Qs_old ; 
     >      rm -f  scanKXi.out_Qs')
      call system('cat scanStabLim.out >> scanStabLim.out_old ; 
     > rm -f scanStabLim.out')
      call system('cat scanStabLim-tunes.out >> 
     > scanStabLim-tunes.out_old ; rm -f scanStabLim-tunes.out')  

C---------- Input data ------------------
      open(unit=lunData,file='scanKXi.data')
      read(lunData,*) xKmi,dK,nK
      read(lunData,*) xiDegMi,dxiDeg, nXi
      close(lunData)

      call system('ln -sf lattice.data scanStabLim.data')
      call readat(lunIn,'scanStabLim.data',
     >                                     nCO)
      call system('rm -f scanStabLim.data')
      write(6,*) ' Inout data read from geneMap.data file, '
      if(nK.le.0) stop '  wrong value nK  '
      if(nXi.le.0) stop  '  wrong value nXi '
      xKma = xKmi + dK*(nK-1.)
      xiDegMa = xiDegMi + dxiDeg * (nXi-1.)
      write(6,*) '  xKmi,xKma,dK,nK  : ',xKmi,xKma,dK,nK
      write(6,*) '  xiDegMi,xiDegMa,dXi,nXi : ',xiDegMi,xiDegMa,
     >                    dxiDeg, nXi
      write(6,*) '  nCO : ', nCO
C----------------------------------------

C Scratch old scanKXi.out
      inquire(file='scanKXi.out',EXIST=EXS)
      if (exs) then
        open(unit=lunOut,name='scanKXi.out')
        close(unit=lunOut,status='delete')
      endif
      open(unit=lunOut,name='scanKXi.out')

c      dK = (xKma - xKmi)/(nK-1.)
      pi = 4. * atan(1.)
c      dxi = (xiDegMa-xiDegMi)/180.*pi  / (nXi -1.)
      dxi = dxiDeg/180.*pi

      CALL TIME(HMS)
      CALL DATE2(DMY)
      WRITE(* ,103) DMY,HMS
 103  FORMAT(/,'  Date :  ',A9,',   time :  ',A8)
      read(hms(1:2),fmt='(i2)') IH     
      read(hms(4:5),fmt='(i2)') MIN
      read(hms(7:8),fmt='(i2)') ISEC      
      read(dmy(1:2),fmt='(i2)') ID
      read(dmy(8:9),fmt='(i2)') IY

      xKi = xKmi - dK
      do k = 1, nK

        result = .true.
        xK = xKi + float(k) *dK
        xi = xiDegMi     /180.*pi
        do ix = 1, nXi

          if(.not. result .and. xiDeg.gt. 50.d0) goto 10

          xiDeg = xi*180./pi
          write(lunOut,*) xK, xiDeg, '  ',nCO,
     >        '  index, spiral angle (rad), # co'

C Change K and xi values in lattice.data
          call system('rm -f lattice.data_temp')
          call change('lattice.data','lattice.data_temp',xK,xiDeg,
     >                                              nCellI,r0I,pfI,gapI)

          open(unit=34,file='tempKXi.dum')
          write(34,*) xK,xiDeg
          close(34)
c              write(*,*)    '      close(34) '
c               pause
C Run geneMap = generate field map, given K, xi ; 
C geneMap also generates initial coordinates near closed orbits 
C       together with data file for zgoubi
          call ellap(id,ih,min,ix,k,nK,nXi)
          call system('ln -sf lattice.data_temp geneMap.data')
          call system('~/zgoubi/struct/ffag/tools/spiralFFAG/geneFieldMa
     >p/geneMap')

C Starting from initial coordinates near closed orbits, look for precise co's
C First, copy zgoubi.dat as generated by geneMap, into input file for searchCO
C          searchCO.temp is a signal liable to be sent by searchCO, means no CO found
          call system('rm -f searchCO.temp')
          call ellap(id,ih,min,ix,k,nK,nXi)
          call system('cp -f zgoubi_geneMap-Out.dat 
     >                                        zgoubi_searchCO-In.dat')
          call system('~/zgoubi/struct/ffag/tools/spiralFFAG/geneFieldMa
     >p/searchCO')
          call system('cat searchCO.out_COs >> scanKXi.out_COs')
          inquire(file='searchCO.temp',exist=exs)
          existCO = .not. exs

C Given the closed orbits, compute paraxial tunes 
          if(first) then
            call system('cat scanKXi.out_Qs >> scanKXi.out_Qs_old ; 
     >                  rm -f scanKXi.out_Qs')
            first = .false.
          endif
c          call system('rm tunesFromMatrix.out')
          if(kTunes.eq.1) then
            call system('cp -f zgoubi_searchCO-Out.dat zgoubi.dat ')
            call track
            call system('~/zgoubi/struct/ffag/tools/spiralFFAG/geneField
     >Map/tunesFromFai')
C Cat output of tunesFromFai procedure into scanKXi.out_Qs
            call system('cat tunesFromFai.out >> scanKXi.out_Qs')
          elseif(kTunes.eq.2) then
C Compute tunes by MATRIX
            call system('cp -f zgoubi_searchCO-Out_MATRIX.dat 
     >                                                 zgoubi.dat ')
            call track

            write(*,*) '  call track  '
            call system('~/zgoubi/struct/ffag/tools/spiralFFAG/geneField
     >Map/tunesFromMatrix')

C Cat output of tunesFromMatrix procedure into scanKXi.out_Qs
            call system('cat tunesFromMatrix.out >> scanKXi.out_Qs')

          endif

          write(*,*) ' '
          write(*,*) '-------------------------------------------------'
          write(*,*) 
     >           'Now get stability limits, starting from closed orbits' 
          write(*,*) ' xK, xi = ',xK, xi/pi*180.d0
          write(*,*) ' '

C Starting from closed orbits, get stability limits
          call system('cp -f zgoubi_searchCO-Out.dat 
     >                                         zgoubi_StabLim-In.dat ')
          call system('~/zgoubi/struct/ffag/tools/spiralFFAG/geneFieldMa
     >p/searchStabLim')
          call system('cat searchStabLim.out >> scanStabLim.out')
          call system('rm -f searchStabLim.out')

          call system('cat searchStabLim-tunes.out >> 
     >                               scanStabLim-tunes.out')
C          call system('rm -f searchStabLim-tunes.out')

          xi = xi + dxi
 10       continue

        enddo  !xi
      enddo  !k

      close(lunOut)

      stop
      end

      FUNCTION STRCON(STR,STRIN,NCHAR,
     >                                IS)
      LOGICAL STRCON
      CHARACTER STR*(*), STRIN*(*)
C     ------------------------------------------------------------------------
C     .TRUE. if the string STR contains the string STRIN with NCHAR characters
C     at least once.
C     IS = position of first occurence of STRIN in STR
C     ------------------------------------------------------------------------

      INTEGER DEBSTR,FINSTR

      II = 0
      DO 1 I = DEBSTR(STR), FINSTR(STR)
        II = II+1
        IF( STR(I:I+NCHAR-1) .EQ. STRIN ) THEN
          IS = II
          STRCON = .TRUE.
          RETURN
        ENDIF
 1    CONTINUE
      STRCON = .FALSE.
      RETURN
      END
      FUNCTION DEBSTR(STRING)
      INTEGER DEBSTR
      CHARACTER * (*) STRING

C     --------------------------------------
C     RENVOIE DANS DEBSTR LE RANG DU
C     1-ER CHARACTER NON BLANC DE STRING,
C     OU BIEN 0 SI STRING EST VIDE ou BLANC.
C     --------------------------------------

      DEBSTR=0
      LENGTH=LEN(STRING)
C      LENGTH=LEN(STRING)+1
1     CONTINUE
        DEBSTR=DEBSTR+1
C        IF(DEBSTR .EQ. LENGTH) RETURN
C        IF (STRING(DEBSTR:DEBSTR) .EQ. ' ') GOTO 1
        IF (STRING(DEBSTR:DEBSTR) .EQ. ' ') THEN
          IF(DEBSTR .EQ. LENGTH) THEN
            DEBSTR = 0
            RETURN
          ELSE
            GOTO 1
          ENDIF
        ENDIF

      RETURN
      END
      FUNCTION FINSTR(STRING)
      INTEGER FINSTR
      CHARACTER * (*) STRING
C     --------------------------------------
C     RENVOIE DANS FINSTR LE RANG DU
C     DERNIER CHARACTER NON BLANC DE STRING,
C     OU BIEN 0 SI STRING EST VIDE ou BLANC.
C     --------------------------------------

      FINSTR=LEN(STRING)+1
1     CONTINUE
        FINSTR=FINSTR-1
        IF(FINSTR .EQ. 0) RETURN
        IF (STRING(FINSTR:FINSTR) .EQ. ' ') GOTO 1

      RETURN
      END
      subroutine track
      write(6,*) 
      write(6,*) '-----'
      write(6,*) ' Now tracking multiturn, busy...' 
      call system('~/zgoubi/source/zgoubi')
      return
      end
      subroutine change(nameIn,nameOut,xK,xiDeg, 
     >                                          nCell,r0,pf,gap)
      character*(*) nameIn, nameOut
      character*132 txt132
      logical strcon, ok
      integer debstr
      data  lunIn, lunOut / 9, 10 /

      open(unit=lunIn,name=nameIn)
      open(unit=lunOut,name=nameOut)

      read(lunIn,fmt='(a)',end=99,err=98)  txt132  !! reads comment line
      write(lunOut,*) txt132

 1    continue

      read(lunIn,fmt='(a)',end=99,err=98)  txt132
      txt132 = txt132(debstr(txt132):132)
     
      if (STRCON(txt132(1:6),'K',1,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                         IS)
        if(ok) write(txt132,fmt='(a,1p,g12.4,a)') 
     >                    'K = ',xK, '  ! value from scan'
      elseif (STRCON(txt132(1:6),'xiDeg',5,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        if(ok) write(txt132,fmt='(a,1p,g12.4,a)') 
     >                     'xiDeg = ',xiDeg,'  ! value from scan'
      endif

      write(lunOut,*) txt132
      write(*,*) txt132

      goto 1

 99   continue
      close(10)
      close(lunIn)
      write(*,*) ' readat ended upon eof'
      goto 97

 98   continue
      close(10)
      close(lunIn)
      write(*,*) ' readat lattice.data ended upon read error'
      goto 97

 97   continue
C For compatibility with earlier version of data file 
      if(T0 .le. 0.d0) T0 = T2

      return
      end
      subroutine change_old(nameIn,nameOut,xK,xiDeg, 
     >                                          nCell,r0,pf,gap)
      character*(*) nameIn, nameOut
      character*132 txt132
      logical strcon, ok
      integer debstr
      data  lunIn / 9 /

      open(unit=lunIn,name=nameIn)
      open(unit=10,name=nameOut)

      read(lunIn,fmt='(a)',end=99,err=98)  txt132  !! reads comment line
      write(10,*) txt132
      write(*,*) txt132

C For compatibility with earlier version of dataFile
      T0 = -1.d0

 1    continue

      read(lunIn,fmt='(a)',end=99,err=98)  txt132
      ideb = debstr(txt132)
      txt132 = txt132(ideb:132)
     
      if (STRCON(txt132(1:6),'K',1,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        write(10,fmt='(a,1p,g12.4,a)') 'K = ',xK, '! value from scan'
      elseif (STRCON(txt132(1:6),'xiDeg',5,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        write(10,fmt='(a,1p,g12.4,a)') 'xiDeg = ',xiDeg,
     >                                    '! value from scan'
      elseif (STRCON(txt132(1:6),'nCell',5,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) nCell
        write(10,*) ' nCell = ', nCell
      elseif (STRCON(txt132(1:6),'r0',2,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) r0
        write(10,*) ' r0 = ', r0
      elseif (STRCON(txt132(1:6),'pf',2,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) pf
        write(10,*) ' pf = ', pf
      elseif (STRCON(txt132(1:6),'gap',3,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) gap
        write(10,*) ' gap = ', gap
      elseif (STRCON(txt132(1:6),'kappa',5,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) akappa
        write(10,*) ' kappa = ', akappa
      elseif (STRCON(txt132(1:6),'T1',2,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) T1
        write(10,*) ' T1 = ', T1
      elseif (STRCON(txt132(1:6),'T2',2,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) T2
        write(10,*) ' T2 = ', T2
      elseif (STRCON(txt132(1:6),'T0',2,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) T0
        write(10,*) ' T0 = ', T0
      elseif (STRCON(txt132(1:6),'nCO',3,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) nCO
        write(10,*) ' nCO = ', nCO
      elseif (STRCON(txt132(1:6),'map',3,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) map
        write(10,*) ' map = ', map
      elseif (STRCON(txt132(1:6),'kaseV',5,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) kaseV
        write(10,*) ' kaseV = ', kaseV
      elseif (STRCON(txt132(1:6),'DltACN',6,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) DltACN
        write(10,*) ' DltACN = ', DltACN
      elseif (STRCON(txt132(1:6),'AT',2,
     >                       IS)) then
        ok=STRCON(txt132,'=',1,
     >                       IS)
        read(txt132(IS+1:132),*) AT
        write(10,*) ' AT = ', AT
      endif

      goto 1

 99   continue
      close(10)
      close(lunIn)
      write(*,*) ' readat ended upon eof'
      goto 97

 98   continue
      close(10)
      close(lunIn)
      write(*,*) ' readat lattice.data ended upon read error'
      goto 97

 97   continue
C For compatibility with earlier version of data file 
      if(T0 .le. 0.d0) T0 = T2

      return
      end
      subroutine ellap(id,ih,min,ix,k,nK,nXi)
      CHARACTER  HMS*8, DMY*9
          WRITE(6,*) ' ' 
          WRITE(6,*) ' #K,  #xi : ',k,'/',nK,'      ',ix,'/',nXi
          CALL TIME(HMS(1:8))
          CALL DATE2(DMY(1:9))
          WRITE(6   ,103) DMY,HMS
 103      FORMAT('  Date :  ',A9,',   time :  ',A8)
          read(hms(1:2),fmt='(i2)') IHC     
          read(hms(4:5),fmt='(i2)') MINC
          read(hms(7:8),fmt='(i2)') ISECC      
          read(dmy(1:2),fmt='(i2)') IDC
          read(dmy(8:9),fmt='(i2)') IYC
          elap=float(idc-id)*86400.d0+float(ihc-ih)*3600.d0
     >               +float(minc-min)*60.d0+float(idc-id)*1.d0
          WRITE(6,*) ' Ellapsed time : ',elap,' sec.'
          write(6,*) ' Estimated remaining time : ',  
     >      elap/float(ix*k)*float(nK-k)*float(nXi-ix)/3600.d0,'  hours'
          WRITE(6,*)
      return
      end
      SUBROUTINE DATE2(DMY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER * (*)   DMY
      CHARACTER*3 MM(12)
      CHARACTER*8 DD
      CHARACTER*10 TT
      CHARACTER*5 ZZ
      INTEGER VV(8)
      DATA MM/'Jan','Feb','Mar','Apr','May','Jun',
     $     'Jul','Aug','Sep','Oct','Nov','Dec'/
      LONG = LEN(DMY)
      IF(LONG.GE.9) THEN
         CALL DATE_AND_TIME(DD,TT,ZZ,VV)
         WRITE(DMY,'(I2.2,1H-,A3,1H-,I2.2)')
     $        VV(3),MM(VV(2)),MOD(VV(1),100)
      ENDIF
      IF(LONG.GT.9) DMY=DMY(1:9)//' '
      RETURN
      END
      subroutine readat(lunIn,fname,
     >                              nCO)
C      implicit double precision (a-h,o-z)
      include "READAT.H"
      return
      end





